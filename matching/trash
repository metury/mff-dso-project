public static boolean existsAugmentingPath(Graph G, HashSet<Edge> I, HashSet<Edge> path, HashSet<Vertex> notCovered){
		for(Vertex v : notCovered){
			
			boolean foundPath = existsAugmentingPathFromVertex(G, I, path, v, new HashSet<Vertex>(), false);
			if(foundPath){
				return true;
			}
			//boolean isInMatching = false;
			//path = existsAugmentingPathRecursive(G, I, current, isInMatching, path);
		}
		return false;
	}
	public static boolean existsAugmentingPathFromVertex(Graph G, HashSet<Edge> I, HashSet<Edge> path, Vertex v, HashSet<Vertex> visitedVertices, boolean hasToBeInMatching ){
		visitedVertices.add(v);
		boolean found = false;
		for(Edge e : v){
			if(I.contains(e) == hasToBeInMatching){
				path.add(e);
				if(visitedVertices.contains(e.getSecondVertex(v))){
					continue;
				}
				found = existsAugmentingPathFromVertex(G, I, path, e.getSecondVertex(v), visitedVertices, !hasToBeInMatching);
				if(found){
					return true;
				}
				path.remove(e);
			}
		}
		return false;
	}
	// If the vertex is not covered by the set.
	private static boolean isNotCovered(HashSet<Edge> I, Vertex v){
		for(Edge e : v){
			if(I.contains(e)){
				return false;
			}
		}
		return true;
	}
	// Find all not covered vertices by the set.
	private static HashSet<Vertex> findAllNotCoveredVertices(Graph G, HashSet<Edge> I){
		HashSet<Vertex> result = new HashSet<Vertex>();
		for(Vertex v : G){
			if(isNotCovered(I,v)){
				result.add(v);
			}
		}
		return result;
	}
		// Find independent set.
	public static HashSet<Edge> findIndependentSet(HashSet<Vertex> Vi){
		HashSet<Edge> I = new HashSet<Edge>();
		for(Vertex v : Vi){
			HashSet<Edge> incident = new HashSet<Edge>();
			HashSet<Edge> intersection = new HashSet<Edge>();
			for(Edge incidentEdge : v){
				incident.add(incidentEdge);
			}
			for(Edge e : v){
				Vertex neighbour = e.getSecondVertex(v);
				for(Edge ne : neighbour){
					if(incident.contains(ne)){
						intersection.add(ne);
					}
				}
			}
			if(intersection.size() <= 1){
				for(Edge e : intersection){
					I.add(e);
				}
			}
		}
		return I;
	}
	
	
	
	/*public static void findMatchingInBipartite(String inputGraph, String output){
		try(BufferedWriter out = new BufferedWriter(new FileWriter(output))){
		
				out.write("# Matching in bipartite graph\n\n");
				out.write("We will find maximal matching in bipartite graph using intersection of matroids. On input we have graph $G$:\n\n");
			
			Graph G = new Graph(inputGraph);
			
			G.exportMermaid(out, true);
			
			HashSet<Vertex> V1 = new HashSet<Vertex>();
			HashSet<Vertex> V2 = new HashSet<Vertex>();
			boolean isBip = isBipartite(G, V1, V2);
			if(!isBip){
				out.write("The graph that was given to us is **not** bipartite. Thus we are terminating this process.\n");
				return;
			}
			
				for(Vertex v : V1) v.setValue(1);
				for(Vertex v : V2) v.setValue(2);
				out.write("We have tested the graph if it is bipartite and also find its parts. Vertices in $V_{1}$ are with value $1$ and in $V_{2}$ have value $2$.\n\n");
				G.exportMermaid(out, true);
				for(Vertex v : V1) v.setValue(Double.NaN);
				for(Vertex v : V2) v.setValue(Double.NaN);
			
				out.write("Now we will find given independent sets. Firstly $I_{1}$ and then $I_{2}$.\n\n");
				out.write("## $I_{1}$\n\n");
			
			HashSet<Edge> I1 = findIndependentSet(V1);
			
			
				boolean[] dotted = new boolean[G.edgeSize()];
				for(int i = 0; i < G.edgeSize(); ++i){
					dotted[i] = true;
				}
				for(Edge e : I1){
					dotted[e.getId()] = false;
				}
				G.exportMermaid(out, true, dotted);
			
			HashSet<Edge> I2 = findIndependentSet(V2);
			
				out.write("## $I_{2}$\n\n");
				
				for(int i = 0; i < G.edgeSize(); ++i){
					dotted[i] = true;
				}
				for(Edge e : I2){
					dotted[e.getId()] = false;
				}
				G.exportMermaid(out, true, dotted);
			
			
			HashSet<Edge> I = I1.size() < I2.size() ? I2 : I1;
			HashSet<Edge> rest = I1.size() < I2.size() ? I1 : I2;
			
			for(Edge e : rest){
				I.add(e);
			}
		} catch (IOException ioe){
			System.err.println(ioe);
		}
	}*/
